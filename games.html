<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Kayle Heideman</title>
	
	<!-- Bootstrap -->
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	
	<!-- Table of Contents | https://afeld.github.io/bootstrap-toc/ -->
	<link rel="stylesheet" href="style/toc.css"/>
	
	<!-- Syntax Highlighter -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
	
	<!-- Mobile compatibility -->
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	
	<style>
		.enlarged {
			width: 102.5% !important; 
			height: 102.5% !important; 
			margin-left: -7.5% !important; 
			
		}
		
		nav[data-toggle="toc"] {
		  top: 42px;
		}

		/* small screens */
		@media (max-width: 768px) {
		  nav[data-toggle="toc"] {
			margin-bottom: 42px;
			position: static;
		  }

		  
		  
		  nav[data-toggle="toc"] .nav-link .active {
			display: block;
		  }
		  
		  nav[data-toggle="toc"] .nav-link {
			  display: none;
			  padding-bottom: 10px;
		  }
		  nav[data-toggle="toc"] .nav > li > a {
			  display: block;
			  padding: 4px 20px;
			  font-size: 13px;
			  font-weight: 500;
			  color: #767676;
			}
		
	</style>
  </head>

  <body style="font-family: Arial, verdona, trebuchet ms, times new roman georgia">
  <!-- Navigation bar -->
  <nav class="navbar navbar-expand-md navbar-light bg-secondary mb-5"><a class="navbar-brand" href="#"><strong>Kayle Heideman</strong></a>
	  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
		<span class="navbar-toggler-icon"></span>
	  </button>

	  <div class="collapse navbar-collapse" id="navbarSupportedContent">
		<ul class="navbar-nav ml-auto navbar-right">
		  
		  <li class="nav-item">
			<a class="nav-link" tabindex="-1" href="index.html">About me</a>
		  </li>
		  
		  <li class="nav-item">
			<a class="nav-link" href="resume.html">Resume</a>
		  </li>
		  
		  <li class="nav-item active">
			<a class="nav-link active" href="#">Games<span class="sr-only">(current)</span></a>
		  </li>
		</ul>
	</div>
  </nav>
  <!-- /Navigation bar -->
  
	<div class="container">
		<div class="row">
			<!-- TOC -->
			<div class="col-sm-2">
				<nav id="toc" class="sticky-top"></nav>
			</div>
			<!-- /TOC -->
	  
	  
			<!-- main content area -->
			<div class="col-sm-8">
			
			<div class="container pb-3 pt-3"> <!-- Game/System Design -->
				<h1>Game/System Design</h1>
				<div class="container ml-5"> <!-- Ancient Artifacts -->
					<h2>Ancient Artifacts</h2>
					<p class="text-secondary">
						This 2-4 player game sees scientists competing over the acquisition of valuable artifacts while
						simultaneously battling against a doomsday count down. Clear obstacles and overcome hazards to reach
						the artifacts that will help the scientists in future acquisition or in hindering the other players. 20-40
						minute play time.
					</p>
					<p>
						Ancient Artifacts is a game about paleontologists and archeologists racing to uncover relics and artifacts as the 
						Doomsday clock encroaches. The primary focuses for game design were player progression, inter-player interaction, 
						and promoting risk-taking behavior. 
						<br><br>
						This game was developed over a 4 month window with iteration and feedback present along the way.
						<br><br>
						<a href="artifacts.html" class="text-primary" target="_blank">Design Document</a> (7 pages)
					</p>
					
					
					<div id="artifactCarousel" class="carousel slide" data-ride="carousel" data-interval="false">
					  <div class="carousel-inner">
						<div class="carousel-item active"> <!-- Game Board --> 
						  <img src="assets/artifacts/board.png" class="card-img-top" alt="...">
						  <div class="row justify-content-center" align="center">
							<p class="text-secondary">Ancient Artifacts board</p>
						  </div>
						</div>
						<div class="carousel-item"> <!-- Game Playing --> 
						  <img src="assets/artifacts/midplay.png" class="card-img-top" alt="...">
						  <div class="row justify-content-center" align="center">
							<p class="text-secondary">Ancient Artifacts mid-game</p>
						  </div>
						</div>
						<div class="carousel-item"> <!-- Celebrity Character --> 
						  <img src="assets/artifacts/celebrity.png" class="card-img-top" alt="...">
						  <div class="row justify-content-center" align="center">
							<p class="text-secondary">Celebrity player character</p>
						  </div>
						</div>
					  </div>
					  <a class="carousel-control-prev" href="#artifactCarousel" role="button" data-slide="prev">
						<span class="carousel-control-prev-icon" aria-hidden="true"></span>
						<span class="sr-only">Previous</span>
					  </a>
					  <a class="carousel-control-next" href="#artifactCarousel" role="button" data-slide="next">
						<span class="carousel-control-next-icon" aria-hidden="true"></span>
						<span class="sr-only">Next</span>
					  </a>
					</div>
					
					
					
				</div>
				<hr>
				<div class="container ml-5"> <!-- Politics in a Nutshell -->
					<h2 class="pb-0 mb-0">Politics in a Nutshell</h2>
					<p class="pt-0 mt-0 text-secondary font-italic">Constraints: 4 hour time limit, game jam, serious game</p>
					<p class="text-secondary">
						This three-player game has players assuming the roles of political parties that wish to get even a single
						issue into policy. Players must fight against or persuade the public’s opinion (as represented by the
						Overton window) in order to move their issue up in the political window until it becomes policy – while
						ideally not allowing others to do the same. Further, each party has an issue that their constituents
						REALLY do not want as Policy. ~15 minutes of play per rounds.
					</p>
					<p>
						 Politics in a Nutshell is a serious game that is meant to make players critically think about how politics influences the public 
						 and vice-versa. Without committing to any political opinions, the game challenges players to put themselves in the shoes of a politician 
						 with three goals: move an idea into policy, stop an opposing idea from moving into policy, and be the first to accomplish these tasks.
						 <br><br>
						 Players must earn political favor to stay in office, utilize money to shift policy, and try to influence the Overton Window 
						 to bring voters to their side. From a game design perspective, the game attempts to use the Three-Player Problem (wherein the two players
						 who are behind will antagonize the leader) as an intended feature. 
						 <br><br>
						 <a href="politics.html" class="text-primary" target="_blank">Design Document</a> (4 pages)
					</p>
					
					<div class="row justify-content-center" align="center">
						<div class="col"> <!-- Game Start -->
							<div class="card hoverenlarge" style="width: 18rem;">
								<img src="assets/politics/game_start.jpg" class="card-img-top" alt="...">
								<div class="card-body">
									<p class="card-text">Game Start</p>
								</div>
							</div>
						</div>
						<div class="col"> <!-- Game End -->
							<div class="card hoverenlarge" style="width: 18rem;">
								<img src="assets/politics/game_end.jpg" class="card-img-top" alt="...">
								<div class="card-body">
									<p class="card-text">Game End</p>
								</div>
							</div>
						</div>
					</div>
					
				</div>
				<hr>
				<div class="container ml-5"> <!-- Pokemon Damage Calculator -->
					<h2 class="pb-0 mb-0">Pokemon Damage Calculator (Systems Design)</h2>
					<p>
						 This spreadsheet shows my ability to implement complex systems into a tool that can be used for game designers 
						 to balance and test values against one another. Custom moves, types, Pokemon and weather are all modifiable from 
						 the useability-first sheet.
						 <br><br>
						 <a href="https://docs.google.com/spreadsheets/d/1r24qSL5NXYViSVhlWmVPxYsbDkmpRYyAfdoapPwRCEI/edit?usp=sharing" class="text-primary" target="_blank">Google Sheets link</a> (7 sheets)
					</p>
					
					<div class="row justify-content-center" align="center">
						<div class="col"> <!-- High Level -->
							<div class="card hoverenlarge" style="width: 18rem;">
								<img src="assets/pokemon/high-level.png" class="card-img-top" alt="...">
								<div class="card-body">
									<p class="card-text">Example 1</p>
								</div>
							</div>
						</div>
						<div class="col"> <!-- Similar Level -->
							<div class="card hoverenlarge" style="width: 18rem;">
								<img src="assets/pokemon/similar-level.png" class="card-img-top" alt="...">
								<div class="card-body">
									<p class="card-text">Example 2</p>
								</div>
							</div>
						</div>
					</div>
					
				</div>
				
			</div>
		
			<hr>
			
			<div class="container pb-3 pt-3"> <!-- Gameplay Programming -->
				<h1>Gameplay Programming</h1>
				<div class="container ml-5"> <!-- GOAP AI -->
					<h2 class="pb-0 mb-0">Goal Oriented Action Planning - Unity Game</h2>
					<p class="pt-0 mt-0 text-secondary font-italic">Constraints: 1 week time frame</p>
					<p>
						This is my implementation of <a href="https://alumni.media.mit.edu/~jorkin/goap.html"  class="text-primary" target="_blank">Goal-Oriented Action Planning</a>, 
						with a small game to go alongside it. There are two types of AI in the game, creatures and humans. Both need to eat and drink to survive, but humans can 
						build structures and chop trees, whereas creatures can nap and poop.
						<br><br>
						The game itself is a small god game, where the player does not interact directly with the AI, rather they influence their actions in vague ways.
						Players can place additional creatures, humans, trees and water canisters to change the environment and see how AI behaves.
						<br><br>
						<a href="https://github.com/KBheid/GOAP_AI" class="text-primary" target="_blank">Github Link</a>
						<br>
						<a href="https://github.com/KBheid/GOAP_AI/blob/main/Assets/ActionPlanner.cs" class="text-primary" target="_blank">Action Planner Direct Link</a>
						
					</p>
					
					<div class="row justify-content-center" align="center">
						<div class="col"> <!-- High Level -->
							<div class="card hoverenlarge" style="width: 18rem;">
								<img src="assets/goap/goap.png" class="card-img-top" alt="...">
								<div class="card-body">
									<p class="card-text">The game world after humans have created some structures. A creature can be seen napping in a tent
									and humans chopping trees.</p>
								</div>
							</div>
						</div>
					</div>
					
				</div>
				<hr>
				<div class="container ml-5"> <!-- Spell Creator -->
					<h2 class="pb-0 mb-0">Spell Creator</h2>
					<p class="pt-0 mt-0 text-secondary font-italic">Constraints: 1 week time frame</p>
					<p>
						The Spell Creator is a player system that I developed roughly based on Morrowind's custom spells. I wanted to demonstrate 
						a new take on the system that allows for customized movement of spells, with support for basic spell effects (such as electric damage). 
						In order to make implementing new spells simpler, I utilized the subclass sandbox pattern. The prototype pattern(ish) was also conceptually useful here, 
						as it allows for simpler copying of a spell. This is used, for example, when splitting a spell into 3, but wanting to retain the effects that follow in the builder 
						for each new spell.
						<br><br>
						<a href="https://github.com/KBheid/SimpleSpellSystem" class="text-primary" target="_blank">Github Link</a>
						
					</p>
					
					<div class="row justify-content-center" align="center">
						<div class="col"> <!-- Spell UI -->
							<div class="card hoverenlarge" style="width: 18rem;">
								<img src="assets/customspell/custom_spell_ui.png" class="card-img-top" alt="...">
								<div class="card-body">
									<p class="card-text">Spell creator UI. (I'm no artist...)</p>
								</div>
							</div>
						</div>
						<div class="col"> <!-- Spell Cast -->
							<div class="card hoverenlarge" style="width: 18rem;">
								<img src="assets/customspell/cast_spell_example.png" class="card-img-top" alt="...">
								<div class="card-body">
									<p class="card-text">An example custom spell that was cast and has left the play field.</p>
								</div>
							</div>
						</div>
					</div>
					
				</div>
				<hr>
				<div class="container ml-5"> <!-- Card Battler Puzzle -->
					<h2 class="pb-0 mb-0">Two Kingdoms - Unity</h2>
					<p class="pt-0 mt-0 text-secondary font-italic">Constraints: 1 week time frame, Puzzle game, Command pattern</p>
					<p>
						This project was done as a test of the command pattern to implement a undo/redo system for a puzzle game. I chose to 
						create a card battle puzzle, similar to Hearthstone's puzzle game modes. I thought that an undo/redo would be particularly interesting 
						to implement for a game like this, as playing some cards can cause chain effects on the board - meaning a single press of the undo button 
						would need to undo all board changes since the last card played.
						<br><br>
						The game as a comprehensive tutorial as well!
						<br><br>
						<a href="https://github.com/KBheid/TwoKingdoms" class="text-primary" target="_blank">Github Link</a> <br>
						<a href="https://github.com/KBheid/TwoKingdoms/blob/main/Assets/Scripts/Commando.cs" class="text-primary" target="_blank">Command Handler direct link</a>
						
					</p>
					
					<div class="row justify-content-center" align="center">
						<div class="col"> <!-- Board -->
							<div class="card hoverenlarge" style="width: 18rem;">
								<img src="assets/cardpuzzle/board.png" class="card-img-top" alt="...">
								<div class="card-body">
									<p class="card-text">The puzzle level</p>
								</div>
							</div>
						</div>
					</div>
					
				</div>
				
			</div>
		
			<hr>
			
			<div class="container pb-3 pt-3"> <!-- Engine Programming/General CS -->
				<h1>Engine Programming/General CS</h1>
				<div class="container ml-5">  <!-- SPE -->
				<h2 class="pb-0 mb-0">Stream Processing Engine</h2>
				<p class="pt-0 mt-0 text-secondary font-italic">Research Project - C++</p>
				<p>
				The Stream Processing Engine was a project that myself and 6 other students undertook during a research class. The engine is designed to take an endless stream of data, allow operators to 'do work' on them, then 
				provide an end point for said data. One application that we utilized the engine for was modifying live camera data to apply filters or distortion effects. Users first set up input streams (of arbitrary
				data type), then define operators that work on the data, which then pass potentially modified data to the next operator. Finally, an end point can be defined that allow users to work with the output of the engine 
				in manageable sizes.One of my personal contributions on this project was to implement a sliding window, which allows users to group data points together, allowing for aggregation and other multi-value operations. 
				<br><br>
				The following code is an example usage of the Stream Processing Engine with Minecraft being an input and output point for the engine. The code below reads in Minecraft chunk data, depending on the player's current 
				region (16x16 chunks). Then, it forwards chunk data to an operator that finds the 'best' chunk for the player to be in, based on the number of diamonds found utilizing an aggregator operator. Finally, the chunk location 
				and diamond locations are forwarded to another operator, which send the data back via TCP connection. My contribution on this demo of the engine also includes work in Python and Java, parsing the world data of 
				Minecraft to send to the engine and receiving the coordinates in game.
				<br><br>
				<a href="https://github.com/nathan-backman/cmsc491-SPE" class="text-primary" target="_blank">Github Repo</a>
				</p>
				<button id="spereveal" class="btn btn-info" data-toggle="collapse" data-target="specode">Toggle Code</button>
				<div id="specode" class="collapse">
				<pre class='brush: cpp'><code class="language-cpp">
// Copyright 2019 [BVU CMSC491 class]
#include &ltiostream&gt
#include &ltfstream&gt
#include &ltsstream&gt
#include &ltstring&gt
#include &ltvector&gt
#include &ltcmath&gt
#include "SPE.h"
#include "TCPListener.h"
#include "MinecraftRegionLoader.h"


TCPListener listener;

struct aggData {
  float chunkVal;
  pos chunkID;
  std::vector&ltpos&gt* oreLocations;
} typedef aggData;


float calcDistance(pos playerPos, pos chunkPos) {
  float x = pow(playerPos.x - chunkPos.x, 2);
  float y = pow(playerPos.y - chunkPos.y, 2);
  float z = pow(playerPos.z - chunkPos.z, 2);
  float dist = sqrt(x+y+z);
  return dist;
}


pos getBlockPos(int i, pos globalChunkPos) {
  //i = y*16*16 + z*16 + x
  pos p;
  int relx, rely, relz, diff;

  rely = i/256;
  diff = i-(rely*256);
  relx = diff % 16;
  relz = (diff - relx)/16;

  p.y = rely + globalChunkPos.y;
  p.z = relz + globalChunkPos.z;
  p.x = relx + globalChunkPos.x;

  return p;
}


class ChunkSelect : public Operator {
  public:
    ChunkSelect(int r, int s) : Operator(r, s) {}
    void processData(Data data) {
      std::cout &lt&lt "chunk select recv one data" &lt&lt std::endl;
      emit(Data(&data, sizeof(aggData)));
      std::cout &lt&lt "chunk select emit data" &lt&lt std::endl;
    }

    void processData() {
      std::cout &lt&lt "chunk select recv data" &lt&lt std::endl;
      aggData bestAgg;
      bestAgg.chunkVal = -1;
      for (Data d : window) {
        if(bestAgg.chunkVal == -1 || bestAgg.chunkVal &lt (*(aggData*)d.value).chunkVal ) {
          if(bestAgg.chunkVal != -1) {
            delete bestAgg.oreLocations;
          }
          bestAgg = *(aggData*)(d.value);
        }
        else {
          delete (*(aggData*)d.value).oreLocations;
        }
      }

      std::cout &lt&lt "chunk select emit data" &lt&lt std::endl;
      emit(Data(&bestAgg, sizeof(aggData)));
    }
};


class ChunkProcessor : public Operator {
  public:
    void processData(Data data) {
      //std::cout &lt&lt "chunk procesessor recv data" &lt&lt std::endl;
      ChunkData &chunk = *(ChunkData*)data.value;

      // Handle an empty chunk
      if (chunk.empty == true) {
        aggData dataToPass;
        dataToPass.oreLocations = new std::vector&ltpos&gt;
        dataToPass.chunkVal = 0;
         
        //std::cout &lt&lt "[empty] chunk procesessor emit data" &lt&lt std::endl;
        emit(Data(&dataToPass, sizeof(aggData)));
        return;
      }

      // Handle an non-empty chunk
      float count = 0;
      aggData dataToPass;
      std::vector&ltpos&gt* oreLocations = new std::vector&ltpos&gt;
      dataToPass.chunkID = chunk.globalChunkPos;

      dataToPass.oreLocations = oreLocations;
      for(int i = 0; i&lt65536 ; i++) {
        if(chunk.chunk[i] == chunk.oreID){
          count++;
          oreLocations-&gtpush_back(getBlockPos(i, chunk.globalChunkPos));
        }
      }

      dataToPass.chunkVal = count/calcDistance(chunk.playerPos, chunk.globalChunkPos);

      //std::cout &lt&lt "[non-empty] chunk procesessor emit data with #ores:" &lt&lt oreLocations-&gtsize() &lt&lt std::endl;
      emit(Data(&dataToPass, sizeof(aggData)));
    }
};


class Generator : public InputSource {
  void generateData() {

    std::cout &lt&lt "Waiting for data from mod..." &lt&lt std::endl;

    std::string strPos;
    while ( (strPos = listener.GetLine()) != "") {
      std::istringstream is(strPos);
      pos playerPos;
      is &gt&gt playerPos.x &gt&gt playerPos.y &gt&gt playerPos.z;
      std::cout &lt&lt "Player pos at: " &lt&lt
        playerPos.x &lt&lt " " &lt&lt
        playerPos.y &lt&lt " " &lt&lt
        playerPos.z &lt&lt std::endl;

      //pos playerPos = {0,0,0};
      MinecraftRegionLoader loader(playerPos);
      std::vector&ltChunkData*&gt chunks = loader.extractChunkData();

      for(int i=0; i &lt chunks.size(); i++) {
        chunks[i]-&gtoreID = 26;
        emit(Data(chunks[i], sizeof(ChunkData)));
      }

      std::cout &lt&lt "Produced " &lt&lt chunks.size() &lt&lt "chunks. Waiting for more data from mod..." &lt&lt std::endl;
    }

    std::cout &lt&lt "Minecraft Mod Disconnected" &lt&lt std::endl;
  }
};


class PrintOp : public Operator{
  public:
    void processData(Data data){

      //std::cout &lt&lt "chunk print recv data" &lt&lt std::endl;
      aggData bestChunk = *(aggData*)data.value;
      std::vector&ltpos&gt ores = *(bestChunk.oreLocations);
      //std::cout &lt&lt "ores size: " &lt&lt ores.size() &lt&lt std::endl;
      for(int i=0; i&ltores.size(); i++){
       std::cout &lt&lt"Chunk: " &lt&lt bestChunk.chunkID.x &lt&lt " " &lt&lt bestChunk.chunkID.z &lt&lt " " &lt&lt bestChunk.chunkID.y &lt&lt std::endl;
       std::cout &lt&lt"Desired Ore at pos: " &lt&lt std::endl;
       std::cout &lt&lt "x: " &lt&lt ores[i].x &lt&lt std::endl;
       std::cout &lt&lt "z: " &lt&lt ores[i].z &lt&lt std::endl;
       std::cout &lt&lt "y: " &lt&lt ores[i].y &lt&lt std::endl;
      }

      if (ores.empty() == false) {
        std::ostringstream os;
        os &lt&lt "Get ore at " &lt&lt ores[0].x &lt&lt " " &lt&lt ores[0].y &lt&lt " " &lt&lt ores[0].z;
        string msg = os.str();
        uint8_t msgSz = msg.size();

        listener.SendData((char*)&msgSz, sizeof(msgSz));
        listener.SendData(msg.c_str(), msgSz);
      }

      delete bestChunk.oreLocations;
    }
};

int main(int argc, char** argv) {
  std::cout &lt&lt "SPE Starting up." &lt&lt std::endl;

  int port = 12345;
  listener.Bind(port);

  std::cout &lt&lt "Waiting for connection..." &lt&lt std::endl;
  if (listener.WaitForConnection() &lt= 0) {
    std::cout &lt&lt "Error - failed to connect" &lt&lt std::endl;
    return 0;
  }

  Generator inputSource;
  ChunkProcessor op1;
  ChunkSelect op2(1024, 1024);
  PrintOp op3;

  StreamProcessingEngine spe;

  spe.addInputSource(&inputSource, {&op1});
  spe.connectOperators(&op1, {&op2});
  spe.connectOperators(&op2, {&op3});

  spe.run();

  std::cout &lt&lt "SPE Finished." &lt&lt std::endl;
  return 0;
}
				</code></pre>
				</div>
			</div>
				<hr>
				<div class="container ml-5">  <!-- I.T.O.M. -->
					<h2 class="pb-0 mb-0">Item Trading over an Online Marketplace</h2>
					<p class="pt-0 mt-0 text-secondary font-italic">I.T.O.M. - Full Stack</p>
					<p class="text-secondary font-italic">
						Item Trading over an Online Marketplace is a full stack application that allows the trading of items between players regardless of the game 
						the users play. This allows users to trade items between games such as Minecraft and Runescape - trading items from one game for items from another.
					</p>
					<p>
						I.T.O.M. was my undergraduate capstone project that I worked on with one other student over the course of a semester. Together, we created a 
						full stack application with custom protocols including a database with serialized game data for in game items. The original pitch included
						two games: Minecraft and Runescape - due to unforseen scoping, this was reduced to only Minecraft. However, the system theoretically supports 
						multiple games, with Runescape being partially implemented game-side utilizing an automated player that facilitates player trades.
						<br><br>
						Utilizing React for the frontend, Spring for the backend, and Postgres as our DBMS, the application was developed in HTML, Javascript, and Java with SQL calls 
						for database interactions. Below are some sample images of the application in use and its architecture.				
						<br><br>
						<a href="https://github.com/KBheid/Itom-Frontend" class="text-primary" target="_blank">Frontend Repo</a> <br>
						<a href="https://github.com/KBheid/Itom-Backend" class="text-primary" target="_blank">Backend Repo</a>
					</p>
					<br>
					
					<div id="itomCarousel" class="carousel slide" data-ride="carousel" data-interval="false">
					  <div class="carousel-inner">
						<div class="carousel-item active"> <!-- Watched Trades --> 
						  <img src="assets/ITOM/watchedTrades.png" class="card-img-top" alt="...">
						  <div class="row justify-content-center" align="center">
							<p class="text-secondary">The watched trades page</p>
						  </div>
						</div>
						<div class="carousel-item"> <!-- Verified Accounts --> 
						  <img src="assets/ITOM/verifiedAccounts.png" class="card-img-top" alt="...">
						  <div class="row justify-content-center" align="center">
							<p class="text-secondary">The verified user accounts page</p>
						  </div>
						</div>
						<div class="carousel-item"> <!-- In Game View --> 
						  <img src="assets/ITOM/inGame.png" class="card-img-top" alt="...">
						  <div class="row justify-content-center" align="center">
							<p class="text-secondary">View in game</p>
						  </div>
						</div>
						<div class="carousel-item"> <!-- Architecture --> 
						  <img src="assets/ITOM/architecture.png" class="card-img-top" alt="...">
						  <div class="row justify-content-center" align="center">
							<p class="text-secondary">The application architecture</p>
						  </div>
						</div>
					  </div>
					  <a class="carousel-control-prev" href="#itomCarousel" role="button" data-slide="prev">
						<span class="carousel-control-prev-icon" aria-hidden="true"></span>
						<span class="sr-only">Previous</span>
					  </a>
					  <a class="carousel-control-next" href="#itomCarousel" role="button" data-slide="next">
						<span class="carousel-control-next-icon" aria-hidden="true"></span>
						<span class="sr-only">Next</span>
					  </a>
					</div>
				
				</div>
				<hr>	
				<div class="container ml-5">  <!-- Memory Manager -->
					<h2>Memory Manager</h2>
					<p>
						More description coming soon, example code below for HeapManager.cpp. Supports byte alignment.
					</p>
					<br><button id="memorymanagerreveal" class="btn btn-info" data-toggle="collapse" data-target="memorymanagercode">Toggle Code</button>
					<div id="memorymanagercode" class="collapse">
					<pre><code class="language-cpp">
#include &ltWindows.h&gt

#include "HeapManager.h"
#include &ltcassert&gt
#include &ltstdio.h&gt
#include &ltmemoryapi.h&gt

bool IsPowerOfTwo(unsigned int x)
{
	return (x & (x - 1)) == 0;
}

inline unsigned int AlignUp(unsigned int i_value, unsigned int i_align)
{
	assert(i_align);
	assert(IsPowerOfTwo(i_align));
	return (i_value + (i_align - 1)) & ~(i_align - 1);
}

inline unsigned int AlignDown(unsigned int i_value, unsigned int i_align)
{
	assert(i_align);
	assert(IsPowerOfTwo(i_align));
	return i_value & ~(i_align - 1);
}



HeapManager::HeapManager(void* i_memStart, const size_t i_maxSize, const unsigned int i_numDescriptors) {
	unsigned int overhead = sizeof(HeapManager) + (sizeof(Descriptor) * i_numDescriptors);

	m_numDescriptors = i_numDescriptors;
	m_memStart = i_memStart;

	// Starting at beginning of total block (i_memStart), write descriptors. They are accounted for in overhead.
	m_unusedBlocks = reinterpret_cast&ltDescriptor*&gt(reinterpret_cast&ltchar*&gt(i_memStart) + sizeof(HeapManager));
	Descriptor* d = m_unusedBlocks;
	for (unsigned int i = 0; i &lt i_numDescriptors; i++) {
		d-&gtstartAddr = nullptr;
		d-&gtsize = 0;
		d-&gtnext = d + 1;
		d++;
	}
	(d - 1)-&gtnext = nullptr; // Set the last item's next to null

	m_maxSize = i_maxSize - overhead;
	m_outstandingAllocList = nullptr;
	m_freeList = getUnusedBlock();
	m_freeList-&gtstartAddr = reinterpret_cast&ltchar*&gt(i_memStart) + overhead;
	m_freeList-&gtsize = m_maxSize;
	m_freeList-&gtnext = nullptr;
}

HeapManager* HeapManager::CreateHeapManager(void* i_memStart, const size_t i_maxSize, const unsigned int i_numDescriptors) {
	assert(i_memStart != nullptr && i_maxSize &gt 0 && i_numDescriptors &gt 0);

	HeapManager* manager = reinterpret_cast&ltHeapManager*&gt(i_memStart);

	return new (manager) HeapManager(i_memStart, i_maxSize, i_numDescriptors);
}

size_t HeapManager::GetLargestFreeBlock() {
	assert(m_freeList != nullptr);
	Descriptor* d = m_freeList;

	size_t maxSize = d-&gtsize;
	while (d != nullptr) {
		maxSize = (d-&gtsize &gt maxSize) ? d-&gtsize : maxSize;
		d = d-&gtnext;
	}

	return maxSize;
}

void* HeapManager::alloc(size_t i_size) {
	Descriptor* d = getFirstFreeBlock(i_size, 1);

	// There is either not enough space or not enough blocks.
	if (d == nullptr)
		return nullptr;

	// Add to outstanding allocations
	d-&gtnext = m_outstandingAllocList;
	m_outstandingAllocList = d;

	return d-&gtstartAddr;
}


void* HeapManager::alloc(size_t i_size, int i_alignment) {
	Descriptor* d = getFirstFreeBlock(i_size, i_alignment);

	// There is either not enough space or not enough blocks.
	if (d == nullptr)
		return nullptr;

	// Add to outstanding allocations
	d-&gtnext = m_outstandingAllocList;
	m_outstandingAllocList = d;

	return d-&gtstartAddr;
}


bool HeapManager::free(void* i_addr) {
	// Nothing allocated.
	if (m_outstandingAllocList == nullptr)
		return false;

	// Check if it is first
	if (m_outstandingAllocList-&gtstartAddr == i_addr) {
		Descriptor* desc = m_outstandingAllocList;
		// remove from outstanding allocations
		m_outstandingAllocList = desc-&gtnext;

		// add into free list
		InsertToFreeList(desc);
		return true;
	}

	// Get the related descriptor
	Descriptor* prev = m_outstandingAllocList;
	Descriptor* cur = prev-&gtnext;
	while (cur != nullptr) {
		if (cur-&gtstartAddr == i_addr) {
			// Remove from outstanding allocations
			prev-&gtnext = cur-&gtnext;

			// Add into free list
			InsertToFreeList(cur);

			return true;
		}

		prev = cur;
		cur = prev-&gtnext;
	}
	
	// Not allocated address
	return false;
}

bool HeapManager::Contains(void* i_addr) {
	if (m_outstandingAllocList == nullptr)
		return false;

	Descriptor* d = m_outstandingAllocList;

	while (d != nullptr) {
		if (i_addr &gt= d-&gtstartAddr && i_addr &lt= reinterpret_cast&ltchar*&gt(d-&gtstartAddr) + d-&gtsize) {
			return true;
		}

		d = d-&gtnext;
	}

	return false;
}

bool HeapManager::IsAllocated(void* i_addr) {
	if (m_outstandingAllocList == nullptr)
		return false;

	Descriptor* d = m_outstandingAllocList;

	while (d != nullptr) {
		if (d-&gtstartAddr == i_addr) {
			return true;
		}

		d = d-&gtnext;
	}

	return false;
}

/*
	Garbage collect - coalesce adjacent blocks
*/
void HeapManager::Collect() {
	// There is nothing to combine if there is none or only one block.
	if (m_freeList == nullptr)
		return;
	if (m_freeList-&gtnext == nullptr)
		return;

	bool madeChange = true;
	while (madeChange) {
		madeChange = false;

		Descriptor* prev = m_freeList;
		Descriptor* cur = prev-&gtnext;

		while (cur != nullptr) {
			char* endPoint = reinterpret_cast&ltchar*&gt(prev-&gtstartAddr) + prev-&gtsize;
			char* curStartPoint = reinterpret_cast&ltchar*&gt(cur-&gtstartAddr);

			// If they are one off, then they're adjacent
			if (endPoint == curStartPoint) {
				// nom nom nom
				prev-&gtsize += cur-&gtsize;
				cur-&gtsize = 0;
				prev-&gtnext = cur-&gtnext;

				// Add cur to unused blocks
				cur-&gtnext = m_unusedBlocks;
				m_unusedBlocks = cur;

				// Move cur because now it's in unused blocks
				cur = prev;
				madeChange = true;
			}

			// Move to the next set
			prev = cur;
			cur = cur-&gtnext;
		}
	}
}


/*
	Gets the first free block that fits the given size. Removes the descriptor from free list and adds
	a new one for the remaining size. 
*/
Descriptor* HeapManager::getFirstFreeBlock(size_t i_size, int i_alignment) {
	// There is no free blocks
	if (m_freeList == nullptr)
		return nullptr;

	// If the first is large enough, allocate it (account for potentially required alignment)
	if (m_freeList-&gtsize &gt i_size + i_alignment) {
		Descriptor* desc = m_freeList;

		// Get an unused block, put it at the start of freeList
		m_freeList = getUnusedBlock();
		
		//if getUnusedBlock returns nullptr, revert
		if (m_freeList == nullptr) {
			m_freeList = desc;
			return nullptr;
		}

		m_freeList-&gtstartAddr = desc-&gtstartAddr;
		m_freeList-&gtnext = desc-&gtnext;

		// Move from back to front to allocate space
		char* unalignedAddr = reinterpret_cast&ltchar*&gt(desc-&gtstartAddr) + desc-&gtsize - i_size;
		unsigned int movedAddr = AlignDown(reinterpret_cast&ltunsigned int&gt(unalignedAddr), i_alignment);
		desc-&gtstartAddr = reinterpret_cast&ltvoid*&gt(movedAddr);

		// Account for the newly aligned sizes
		m_freeList-&gtsize = reinterpret_cast&ltchar*&gt(desc-&gtstartAddr) - reinterpret_cast&ltchar*&gt(m_freeList-&gtstartAddr);
		desc-&gtsize = i_size + reinterpret_cast&ltunsigned int&gt(unalignedAddr) - movedAddr;

		return desc;
	}

	Descriptor* prev = m_freeList;
	Descriptor* cur = prev-&gtnext;
	while (cur != nullptr) {
		if (cur-&gtsize &gt i_size + i_alignment) {
			// Set up a replacement for the remaining size, set up pointers accordingly
			Descriptor* replacement = getUnusedBlock();

			// If getUnusedBlock returns nullptr, bail
			if (replacement == nullptr)
				return nullptr;

			replacement-&gtstartAddr = cur-&gtstartAddr;
			replacement-&gtnext = cur-&gtnext;

			// Move from back to front to allocate space
			char* unalignedAddr = reinterpret_cast&ltchar*&gt(cur-&gtstartAddr) + cur-&gtsize - i_size;
			unsigned int movedAddr = AlignDown(reinterpret_cast&ltunsigned int&gt(unalignedAddr), i_alignment);
			cur-&gtstartAddr = reinterpret_cast&ltvoid*&gt(movedAddr);

			prev-&gtnext = replacement;

			// Update size and return
			cur-&gtsize = i_size + reinterpret_cast&ltunsigned int&gt(unalignedAddr) - movedAddr;
			replacement-&gtsize = reinterpret_cast&ltchar*&gt(cur-&gtstartAddr) - reinterpret_cast&ltchar*&gt(replacement-&gtstartAddr);
			return cur;
		}

		prev = cur;
		cur = prev-&gtnext;
	}

	// None of size
	return nullptr;
}

Descriptor* HeapManager::getUnusedBlock() {
	if (m_unusedBlocks == nullptr)
		return nullptr;

	Descriptor* o_desc = m_unusedBlocks;
	m_unusedBlocks = o_desc-&gtnext;

	return o_desc;
}


void HeapManager::ShowOutstandingAllocations() {
	Descriptor* d = m_outstandingAllocList;

	printf("Allocated List:\n");
	while (d != nullptr) {
		printf("\t selfAddr: %p \t startAddr: %p \t size:%d \t next: %p\n", d, d-&gtstartAddr, d-&gtsize, d-&gtnext);
		d = d-&gtnext;
	}
}

void HeapManager::ShowFreeBlocks() {
	Descriptor* d = m_freeList;

	printf("Free List:\n");
	while (d != nullptr) {
 		printf("\t selfAddr: %p \t startAddr: %p \t size:%d \t next: %p\n", d, d-&gtstartAddr, d-&gtsize, d-&gtnext);
		d = d-&gtnext;
	}
}

void HeapManager::InsertToFreeList(Descriptor* i_desc) {
	// Check if it is the first item
	if (m_freeList == nullptr || m_freeList-&gtstartAddr &gt i_desc-&gtstartAddr) {
		// push onto front
		i_desc-&gtnext = m_freeList;
		m_freeList = i_desc;

		return;
	}
	
	// Otherwise, iterate list and place in sorted order
	Descriptor* prev = m_freeList;
	Descriptor* cur = prev-&gtnext;
	while (cur != nullptr) {
		if (prev-&gtstartAddr &lt i_desc-&gtstartAddr && cur-&gtstartAddr &gt i_desc-&gtstartAddr) {
			// Place in between
			prev-&gtnext = i_desc;
			i_desc-&gtnext = cur;

			return;
		}

		prev = cur;
		cur = prev-&gtnext;
	}
	
	// Finally, if it was never placed, put it at the end
	prev-&gtnext = i_desc;
	i_desc-&gtnext = nullptr;
}


void HeapManager::Destroy() {
	VirtualFree(m_memStart, 0, MEM_RELEASE);
}
					</code></pre>
					</div>
				</div>
			
		</div>
	</div>
  
  
	
	
	<!-- Bootstrap -->
	<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.7/dist/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
	
	<!-- Table of Contents -->
	<script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.js"></script>
	
	<!-- Syntax Highlighter -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
  
	<script>
		$('.hoverenlarge').hover(function(){
			$(this).toggleClass("enlarged");
		},function(){
			$(this).toggleClass("enlarged");
		});
		
		$(function () {
		  var navSelector = "#toc";
		  var $myNav = $(navSelector);
		  Toc.init($myNav);
		  $("body").scrollspy({
			target: navSelector,
		  });
		});
		
		$('#spereveal').click(function() {
			$('#specode').collapse("toggle");		
		});
		
		$('#memorymanagerreveal').click(function() {
			$('#memorymanagercode').collapse("toggle");
		});
		
		hljs.highlightAll();
	</script>
  </body>
</html>
